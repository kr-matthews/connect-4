{"version":3,"sources":["Options.js","Lobby.js","Header.js","Board.js","Footer.js","useGame.js","Room.js","App.js","index.js"],"names":["Options","Lobby","Header","Row","viewer","row","placePiece","colours","toPlayNext","rowCells","map","col","player","inLine","Cell","backgroundColor","pieceStyle","borderColor","cellClass","className","onClick","style","Board","board","tableRows","length","push","Footer","resetGame","boardReducer","state","action","type","emptyBoard","boardSize","newState","findWin","success","r_0","c_0","d_r","d_c","k","moveHistory","historyReducer","pop","console","log","rows","cols","r","c","directions","forEach","d_row","d_col","current","opponentReducer","property","value","Room","useState","useReducer","name","colour","opponent","toPlayFirst","gameStatus","setGameStatus","setToPlayNext","dispatchMove","dispatchHistory","useEffect","hasNull","entry","full","boardState","findEmptyRow","useGame","App","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.d25de0e6.chunk.js","sourcesContent":["function Options() {\n  // TODO: Options component\n  return <p>Options: set name, colour, theme</p>;\n}\n\nexport default Options;\n","function Lobby() {\n  // TODO: Lobby component\n  return (\n    <>\n      <h2>Lobby</h2>\n      <p>Create or join a room.</p>\n    </>\n  );\n}\n\nexport default Lobby;\n","function Header() {\n  // TODO: Header component\n  return (\n    <p>\n      Header: room status (names, colours, w-l-d record), room reset options.\n    </p>\n  );\n}\n\nexport default Header;\n","import \"./board.css\";\n\nfunction Board({ viewer, board, placePiece, colours, toPlayNext }) {\n  const rows = board.length;\n  let tableRows = [];\n  // the first row goes on the bottom, visually\n  for (let row = rows - 1; row > -1; row--) {\n    tableRows.push(\n      <Row\n        key={row}\n        viewer={viewer}\n        row={board[row]}\n        placePiece={placePiece}\n        colours={colours}\n        toPlayNext={toPlayNext}\n      />\n    );\n  }\n\n  return (\n    <table className=\"board\" style={{ backgroundColor: \"Black\" }}>\n      <tbody>{tableRows}</tbody>\n    </table>\n  );\n}\n\nfunction Row({ viewer, row, placePiece, colours, toPlayNext }) {\n  let rowCells = row.map(({ player, inLine }, col) => {\n    return (\n      <Cell\n        key={col}\n        viewer={viewer}\n        col={col}\n        player={player}\n        placePiece={placePiece}\n        colours={colours}\n        inLine={inLine}\n        toPlayNext={toPlayNext}\n      />\n    );\n  });\n\n  return <tr>{rowCells}</tr>;\n}\n\nfunction Cell({\n  viewer,\n  col,\n  player,\n  placePiece,\n  colours,\n  inLine,\n  toPlayNext,\n}) {\n  const backgroundColor = colours[player] || \"White\";\n  const borderColor = inLine ? oppColour(backgroundColor) : backgroundColor;\n  const pieceStyle = { backgroundColor, borderColor };\n\n  // can click if there is no piece && the viewer is next to play\n  // note that if game is over, toPlayNext is null so this works\n  const isClickable = player === null && viewer === toPlayNext;\n  const cellClass = isClickable ? \"clickable cell\" : \"cell\";\n  const clickHandler = () => player === null && placePiece(toPlayNext, col);\n  // TEMP: change cellOnClick check to isClickable, as in cellClass\n\n  return (\n    <td className={cellClass} onClick={clickHandler}>\n      <span className=\"piece\" style={pieceStyle}></span>\n    </td>\n  );\n}\n\nfunction oppColour(colour) {\n  // TODO: calculate opposite colour (just using White for now)\n  return \"White\";\n}\n\nexport default Board;\nexport { Row, Cell }; // for testing\n","function Footer({ resetGame }) {\n  // TODO: Footer component\n  return (\n    <>\n      <p>Footer: game status (onging/lost/etc), game reset options.</p>\n      <button onClick={() => resetGame(0)}>Reset Game</button>\n    </>\n  );\n}\n\nexport default Footer;\n","import { useState, useReducer, useEffect } from \"react\";\n\n//// reducers\n// outside the hook function to ensure they are pure\n\nfunction boardReducer(state, action) {\n  switch (action.type) {\n    case \"reset\":\n      return emptyBoard(action.boardSize);\n    case \"placePiece\":\n      let newState = [...state];\n      // add the piece\n      newState[action.row][action.col].player = action.player;\n      // if there is a new, highlight the winning pieces\n      let { success, r_0, c_0, d_r, d_c } = findWin(\n        newState,\n        action.row,\n        action.col\n      );\n      if (success) {\n        // NOTE: another use of 4 from \"connect 4\"\n        for (let k = 0; k < 4; k++) {\n          newState[r_0 + k * d_r][c_0 + k * d_c].inLine = true;\n        }\n      }\n      return newState;\n    case \"undo\":\n      // NOTE: this case is currently not used\n      // TODO: build in UNDO to interface and add workflow -- note it needs moveHistory passed in\n      if (action.moveHistory === []) {\n        return state;\n      } else {\n        let newState = [...state];\n        delete newState[action.row][action.col].player;\n        // TODO: unhighlight winning positions if necessary\n        return newState;\n      }\n    default:\n      return state;\n  }\n}\n\nfunction historyReducer(state, action) {\n  switch (action.type) {\n    case \"reset\":\n      return [];\n    case \"addMove\":\n      let newState = [...state];\n      let { player, row, col } = action;\n      newState.push({ player, row, col });\n      return newState;\n    case \"undo\":\n      if (state === []) {\n        return state;\n      } else {\n        let newState = [...state];\n        newState.pop();\n        return newState;\n      }\n    default:\n      console.log(\"historyReducer switch didn't match any case\");\n      return state;\n  }\n}\n\n//// helpers for reducers\n\n// create initial empty board (on resets)\nfunction emptyBoard([rows, cols]) {\n  let board = [];\n  for (let r = 0; r < rows; r++) {\n    let row = [];\n    for (let c = 0; c < cols; c++) {\n      row.push({ player: null, inLine: false });\n    }\n    board.push(row);\n  }\n  return board;\n}\n\n// find row that piece will end up in\nfunction findEmptyRow(boardState, col) {\n  let rows = boardState.length;\n  for (let row = 0; row < rows; row++) {\n    if (boardState[row][col].player === null) {\n      return row;\n    }\n  }\n  return null;\n}\n\n//// helpers for effects\n// outside to ensure pure (to avoid being needed in the dependency array)\n\nconst directions = [\n  [0, 1],\n  [1, 0],\n  [1, 1],\n  [-1, 1],\n];\n\nfunction full(board) {\n  let hasNull = false;\n  // check the top row for nulls\n  board[board.length - 1].forEach((entry) => {\n    if (entry.player === null) {\n      hasNull = true;\n    }\n  });\n  return !hasNull;\n}\n\n// NOTE: this is the main place that 4 from \"connect 4\" is used\nfunction findWin(board, row, col) {\n  const [rows, cols] = [board.length, board[0].length];\n  const player = board[row][col].player;\n  if (player === null) {\n    return { success: false };\n  }\n  let success = false;\n  let [r_0, c_0, d_r, d_c] = [null, null, null, null];\n  directions.forEach(([d_row, d_col]) => {\n    if (!success) {\n      // no need to proceed if we already found a win\n      // reset return values\n      [r_0, c_0, d_r, d_c] = [null, null, d_row, d_col];\n      let current = 0;\n      for (let k = -3; k < 4; k++) {\n        if (\n          -1 < row + k * d_row &&\n          row + k * d_row < rows &&\n          -1 < col + k * d_col &&\n          col + k * d_col < cols &&\n          board[row + k * d_row][col + k * d_col].player === player\n        ) {\n          // if the player has a piece here\n          if (current === 0) {\n            // if the piror piece was not compatible (wrong player or out of bounds)\n            // then this is the new start\n            r_0 = row + k * d_row;\n            c_0 = col + k * d_col;\n          }\n          current += 1;\n          if (current >= 4) {\n            // found a winner\n            success = true;\n          }\n        } else {\n          // no piece here -- reset\n          current = 0;\n        }\n      }\n    }\n  });\n\n  return { success, r_0, c_0, d_r, d_c };\n}\n\nfunction useGame(toPlayFirst) {\n  //// Constants\n\n  // to change board dimensions, change this\n  // NOTE: maybe add as prop for hook?\n  const boardSize = [6, 7];\n  // the possible line directions (horizontal, vertical, diagonal, anti-diagonal)\n\n  //// States\n\n  // NOTE: probably better to store board state and winning indices separately,\n  //  then combine them into a const to return to the component,\n  //  rather than having them in the same state -- makes updates more awkward\n\n  // ongoing, draw, or the index of a player\n  const [gameStatus, setGameStatus] = useState(\"ongoing\");\n  // index of player to play next move\n  const [toPlayNext, setToPlayNext] = useState(toPlayFirst);\n  // matrix, row 0 at the bottom; each cell is an object\n  const [board, dispatchMove] = useReducer(boardReducer, emptyBoard(boardSize));\n  // stack (array) of {player, row, col}\n  const [moveHistory, dispatchHistory] = useReducer(historyReducer, []);\n\n  //// Effects\n\n  // check for win/draw\n  useEffect(() => {\n    if (moveHistory.length > 0) {\n      let { row, col } = moveHistory[moveHistory.length - 1];\n      let { success } = findWin(board, row, col);\n      if (gameStatus === \"ongoing\" && success) {\n        // the game state should be the index of the winner\n        setGameStatus(board[row][col].player);\n        setToPlayNext(null);\n      } else if (gameStatus === \"ongoing\" && full(board)) {\n        // it's a draw\n        setGameStatus(\"draw\");\n        setToPlayNext(null);\n      }\n    }\n  }, [moveHistory, board, gameStatus]);\n\n  //// Externally accessible functions\n\n  // given out to reset all states\n  function resetGame(player) {\n    setGameStatus(\"ongoing\");\n    setToPlayNext(player);\n    dispatchMove({ type: \"reset\", boardSize });\n    dispatchHistory({ type: \"reset\" });\n  }\n\n  // given out to allow component to (attempt to) place a piece\n  function placePiece(player, col) {\n    let row = findEmptyRow(board, col);\n    if (gameStatus === \"ongoing\" && player === toPlayNext && row !== null) {\n      // move is possible; proceed\n      dispatchMove({ type: \"placePiece\", player, row, col });\n      dispatchHistory({ type: \"addMove\", player, row, col });\n      setToPlayNext(1 - player);\n      // gameStatus is then updated via a useEffect\n    }\n  }\n\n  // Return\n\n  return { gameStatus, toPlayNext, board, moveHistory, resetGame, placePiece };\n\n  // TODO: return an undo function, rather than the moveHistory?\n}\n\nexport { useGame };\n","import { useState, useReducer } from \"react\";\n\nimport Header from \"./Header.js\";\nimport Board from \"./Board.js\";\nimport Footer from \"./Footer.js\";\n\nimport { useGame } from \"./useGame.js\";\n\n//// reducers\n\nfunction opponentReducer(state, action) {\n  let newState = [...state];\n  newState[action.property] = action.value;\n  return newState;\n}\n\n// the room is seen from the current player's view\n//  each player has their own instantiation of the 'shared' room\n\nfunction Room() {\n  // TODO: keep playerCount and opponent -- involves network\n\n  //// States\n\n  // how many players are present\n  // TEMP: initial state -- should be 2 if joining someone else's room\n  const [playerCount, setPlayerCount] = useState(1);\n  // other player's name and colour, once they join\n  // TEMP: initial state -- should check network and be null if necessary\n  const [opponent, dispatchOpponent] = useReducer(opponentReducer, {\n    name: \"Bob\",\n    colour: \"red\",\n  });\n  // the game custom hook\n  const {\n    gameStatus,\n    toPlayNext,\n    board,\n    // moveHistory, // TEMP: hide\n    resetGame,\n    placePiece,\n  } = useGame(0); // TEMP: argument of 0 (index of first palyer)\n  // TODO: allow someone to pick method for first-player selection\n\n  //// Return\n\n  return (\n    <>\n      <h2>Room</h2>\n      <Header />\n      <Board\n        viewer={0}\n        board={board}\n        placePiece={placePiece}\n        colours={[\"Blue\", opponent.colour]} // TEMP: get blue from context\n        toPlayNext={toPlayNext}\n      />\n      <Footer gameStatus={gameStatus} resetGame={resetGame} />\n    </>\n  );\n}\n\nexport default Room;\n","import Options from \"./Options.js\";\nimport Lobby from \"./Lobby.js\";\nimport Room from \"./Room.js\";\n\nfunction App() {\n  // TODO: add Links component\n  return (\n    <>\n      <h1>Connect 4 [WIP]</h1>\n      <Options />\n      {true && <Lobby />}\n      {true && <Room />}\n    </>\n  );\n}\n\nexport default App;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\n\nimport App from \"./App\";\n\nimport \"./index.css\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n"],"sourceRoot":""}