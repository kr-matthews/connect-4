{"version":3,"sources":["Options.js","Lobby.js","Header.js","Board.js","Footer.js","useGame.js","Room.js","App.js","index.js"],"names":["Options","Lobby","Header","Row","row","placePiece","colours","toPlayNext","rowCells","map","col","player","inLine","Cell","cellClass","cellOnClick","a","b","className","onClick","style","backgroundColor","borderColor","styleColour","Board","board","tableRows","length","push","Footer","resetGame","boardReducer","state","action","type","emptyBoard","boardSize","newState","findWin","success","r_0","c_0","d_r","d_c","k","moveHistory","historyReducer","pop","console","log","rows","cols","r","c","directions","forEach","d_row","d_col","current","Room","creator","useState","useReducer","property","value","name","colour","players","toPlayFirst","gameStatus","setGameStatus","setToPlayNext","dispatchMove","dispatchHistory","useEffect","hasNull","entry","full","boardState","findEmptyRow","useGame","App","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"yMAKeA,MALf,WAEE,OAAO,kECQMC,MAVf,WAEE,OACE,qCACE,uCACA,2D,cCISC,MATf,WAEE,OACE,yG,MCsBJ,SAASC,EAAT,GAAwD,IAAzCC,EAAwC,EAAxCA,IAAKC,EAAmC,EAAnCA,WAAYC,EAAuB,EAAvBA,QAASC,EAAc,EAAdA,WACnCC,EAAWJ,EAAIK,KAAI,WAAqBC,GAAS,IAA3BC,EAA0B,EAA1BA,OAAQC,EAAkB,EAAlBA,OAChC,OACE,cAACC,EAAD,CAEEH,IAAKA,EACLC,OAAQA,EACRN,WAAYA,EACZC,QAASA,EACTM,OAAQA,EACRL,WAAYA,GANPG,MAWX,OAAO,6BAAKF,IAKd,SAASK,EAAT,GAAyE,IAAzDH,EAAwD,EAAxDA,IAAKC,EAAmD,EAAnDA,OAAQN,EAA2C,EAA3CA,WAAYC,EAA+B,EAA/BA,QAASM,EAAsB,EAAtBA,OAAQL,EAAc,EAAdA,WAQxD,IAAMO,EAAuB,OAAXH,EAAkB,iBAAmB,OACjDI,EAAyB,OAAXJ,EAAkBN,EAAa,SAACW,EAAGC,KAEvD,OACE,oBAAIC,UAAWJ,EAAWK,QAAS,kBAAMJ,EAAYR,EAAYG,IAAjE,SACc,OAAXC,GAAmB,sBAAMO,UAAU,QAAQE,MAZhD,WACE,IAAIC,EAAkBf,EAAQK,GAI9B,MAAO,CAAEU,kBAAiBC,YAHRV,EAiBb,QAfDS,GAQiDE,OAU1CC,MAlEf,YAIE,IAJ0D,IAA3CC,EAA0C,EAA1CA,MAAOpB,EAAmC,EAAnCA,WAAYC,EAAuB,EAAvBA,QAASC,EAAc,EAAdA,WAEvCmB,EAAY,GAEPtB,EAHEqB,EAAME,OAGK,EAAGvB,GAAO,EAAGA,IACjCsB,EAAUE,KACR,cAACzB,EAAD,CAEEC,IAAKqB,EAAMrB,GACXC,WAAYA,EACZC,QAASA,EACTC,WAAYA,GAJPH,IASX,OACE,uBAAOc,UAAU,QAAjB,SACE,gCAAQQ,OCVCG,MAVf,YAAgC,IAAdC,EAAa,EAAbA,UAEhB,OACE,qCACE,2FACA,wBAAQX,QAAS,kBAAMW,EAAU,IAAjC,4BCAN,SAASC,EAAaC,EAAOC,GAC3B,OAAQA,EAAOC,MACb,IAAK,QACH,OAAOC,EAAWF,EAAOG,WAC3B,IAAK,aACH,IAAIC,EAAQ,YAAOL,GAEnBK,EAASJ,EAAO7B,KAAK6B,EAAOvB,KAAKC,OAASsB,EAAOtB,OAHnD,MAKwC2B,EACpCD,EACAJ,EAAO7B,IACP6B,EAAOvB,KAHH6B,EALR,EAKQA,QAASC,EALjB,EAKiBA,IAAKC,EALtB,EAKsBA,IAAKC,EAL3B,EAK2BA,IAAKC,EALhC,EAKgCA,IAK9B,GAAIJ,EAEF,IAAK,IAAIK,EAAI,EAAGA,EAAI,EAAGA,IACrBP,EAASG,EAAMI,EAAIF,GAAKD,EAAMG,EAAID,GAAK/B,QAAS,EAGpD,OAAOyB,EACT,IAAK,OAGH,GAAIJ,EAAOY,cAAgB,GACzB,OAAOb,EAEP,IAAIK,EAAQ,YAAOL,GAGnB,cAFOK,EAASJ,EAAO7B,KAAK6B,EAAOvB,KAAKC,OAEjC0B,EAEX,QACE,OAAOL,GAIb,SAASc,EAAed,EAAOC,GAC7B,OAAQA,EAAOC,MACb,IAAK,QACH,MAAO,GACT,IAAK,UACH,IAAIG,EAAQ,YAAOL,GACbrB,EAAqBsB,EAArBtB,OAAQP,EAAa6B,EAAb7B,IAAKM,EAAQuB,EAARvB,IAEnB,OADA2B,EAAST,KAAK,CAAEjB,SAAQP,MAAKM,QACtB2B,EACT,IAAK,OACH,GAAIL,IAAU,GACZ,OAAOA,EAEP,IAAIK,EAAQ,YAAOL,GAEnB,OADAK,EAASU,MACFV,EAEX,QAEE,OADAW,QAAQC,IAAI,+CACLjB,GAOb,SAASG,EAAT,GAEE,IAFiC,IAAD,mBAAbe,EAAa,KAAPC,EAAO,KAC5B1B,EAAQ,GACH2B,EAAI,EAAGA,EAAIF,EAAME,IAAK,CAE7B,IADA,IAAIhD,EAAM,GACDiD,EAAI,EAAGA,EAAIF,EAAME,IACxBjD,EAAIwB,KAAK,CAAEjB,OAAQ,KAAMC,QAAQ,IAEnCa,EAAMG,KAAKxB,GAEb,OAAOqB,EAiBT,IAAM6B,EAAa,CACjB,CAAC,EAAG,GACJ,CAAC,EAAG,GACJ,CAAC,EAAG,GACJ,EAAE,EAAG,IAeP,SAAShB,EAAQb,EAAOrB,EAAKM,GAAM,IAAD,EACX,CAACe,EAAME,OAAQF,EAAM,GAAGE,QAAtCuB,EADyB,KACnBC,EADmB,KAE1BxC,EAASc,EAAMrB,GAAKM,GAAKC,OAC/B,GAAe,OAAXA,EACF,MAAO,CAAE4B,SAAS,GAEpB,IAAIA,GAAU,EACTC,EAAuB,KAAlBC,EAAwB,KAAnBC,EAAyB,KAApBC,EAA0B,KAmC9C,OAlCAW,EAAWC,SAAQ,YAAqB,IAAD,mBAAlBC,EAAkB,KAAXC,EAAW,KACrC,IAAKlB,EAAS,CAGXC,EAAuB,KAAlBC,EAAwB,KAAnBC,EAAyBc,EAApBb,EAA2Bc,EAE3C,IADA,IAAIC,EAAU,EACLd,GAAK,EAAGA,EAAI,EAAGA,KAEnB,EAAIxC,EAAMwC,EAAIY,GACfpD,EAAMwC,EAAIY,EAAQN,IACjB,EAAIxC,EAAMkC,EAAIa,GACf/C,EAAMkC,EAAIa,EAAQN,GAClB1B,EAAMrB,EAAMwC,EAAIY,GAAO9C,EAAMkC,EAAIa,GAAO9C,SAAWA,GAGnC,IAAZ+C,IAGFlB,EAAMpC,EAAMwC,EAAIY,EAChBf,EAAM/B,EAAMkC,EAAIa,IAElBC,GAAW,IACI,IAEbnB,GAAU,IAIZmB,EAAU,MAMX,CAAEnB,UAASC,MAAKC,MAAKC,MAAKC,OClGpBgB,MAjDf,YAA2B,EAAXC,QAAY,IAAD,EAQaC,mBAAS,GARtB,gCAaKC,sBAe9B,SAAyB9B,EAAOC,GAC9B,IAAII,EAAQ,YAAOL,GAEnB,OADAK,EAASJ,EAAOtB,QAAQsB,EAAO8B,UAAY9B,EAAO+B,MAC3C3B,IAlBiD,CACxD,CAAE4B,KAAM,QAASC,OAAQ,QACzB,CAAED,KAAM,MAAOC,OAAQ,UAfA,mBAalBC,EAbkB,aDsJ3B,SAAiBC,GAKf,IAAMhC,EAAY,CAAC,EAAG,GALM,EAeQyB,mBAAS,WAfjB,mBAerBQ,EAfqB,KAeTC,EAfS,OAiBQT,mBAASO,GAjBjB,mBAiBrB7D,EAjBqB,KAiBTgE,EAjBS,OAmBET,qBAAW/B,EAAcI,EAAWC,IAnBtC,mBAmBrBX,EAnBqB,KAmBd+C,EAnBc,OAqBWV,qBAAWhB,EAAgB,IArBtC,mBAqBrBD,EArBqB,KAqBR4B,EArBQ,KAkE5B,OAxCAC,qBAAU,WACR,GAAI7B,EAAYlB,OAAS,EAAG,CAAC,IAAD,EACPkB,EAAYA,EAAYlB,OAAS,GAA9CvB,EADoB,EACpBA,IAAKM,EADe,EACfA,IACL6B,EAAYD,EAAQb,EAAOrB,EAAKM,GAAhC6B,QACa,YAAf8B,GAA4B9B,GAE9B+B,EAAc7C,EAAMrB,GAAKM,GAAKC,QAC9B4D,EAAc,OACU,YAAfF,GA3FjB,SAAc5C,GACZ,IAAIkD,GAAU,EAOd,OALAlD,EAAMA,EAAME,OAAS,GAAG4B,SAAQ,SAACqB,GACV,OAAjBA,EAAMjE,SACRgE,GAAU,OAGNA,EAmFmCE,CAAKpD,KAE1C6C,EAAc,QACdC,EAAc,UAGjB,CAAC1B,EAAapB,EAAO4C,IA0BjB,CAAEA,aAAY9D,aAAYkB,QAAOoB,cAAaf,UArBrD,SAAmBnB,GACjB2D,EAAc,WACdC,EAAc5D,GACd6D,EAAa,CAAEtC,KAAM,QAASE,cAC9BqC,EAAgB,CAAEvC,KAAM,WAiBsC7B,WAbhE,SAAoBM,EAAQD,GAC1B,IAAIN,EAnIR,SAAsB0E,EAAYpE,GAEhC,IADA,IAAIwC,EAAO4B,EAAWnD,OACbvB,EAAM,EAAGA,EAAM8C,EAAM9C,IAC5B,GAAoC,OAAhC0E,EAAW1E,GAAKM,GAAKC,OACvB,OAAOP,EAGX,OAAO,KA4HK2E,CAAatD,EAAOf,GACX,YAAf2D,GAA4B1D,IAAWJ,GAAsB,OAARH,IAEvDoE,EAAa,CAAEtC,KAAM,aAAcvB,SAAQP,MAAKM,QAChD+D,EAAgB,CAAEvC,KAAM,UAAWvB,SAAQP,MAAKM,QAChD6D,EAAc,EAAI5D,MCvLlBqE,CAAQ,IANVX,EApBuB,EAoBvBA,WACA9D,EArBuB,EAqBvBA,WACAkB,EAtBuB,EAsBvBA,MAEAK,EAxBuB,EAwBvBA,UACAzB,EAzBuB,EAyBvBA,WASF,OACE,qCACE,sCACA,cAAC,EAAD,IACA,cAAC,EAAD,CACEoB,MAAOA,EACPpB,WAAYA,EACZC,QAAS,CAAC6D,EAAQ,GAAGD,OAAQC,EAAQ,GAAGD,QACxC3D,WAAYA,IAEd,cAAC,EAAD,CAAQ8D,WAAYA,EAAYvC,UAAWA,QCpClCmD,MAZf,WAEE,OACE,qCACE,iDACA,cAAC,EAAD,IACS,cAAC,EAAD,IACA,cAAC,EAAD,Q,MCJfC,IAASC,OACP,cAAC,IAAMC,WAAP,UACE,cAAC,EAAD,MAEFC,SAASC,eAAe,W","file":"static/js/main.eb6e2947.chunk.js","sourcesContent":["function Options() {\n  // TODO: Options component\n  return <p>Options: set name, colour, theme</p>;\n}\n\nexport default Options;\n","function Lobby() {\n  // TODO: Lobby component\n  return (\n    <>\n      <h2>Lobby</h2>\n      <p>Create or join a room.</p>\n    </>\n  );\n}\n\nexport default Lobby;\n","function Header() {\n  // TODO: Header component\n  return (\n    <p>\n      Header: room status (names, colours, w-l-d record), room reset options.\n    </p>\n  );\n}\n\nexport default Header;\n","import \"./board.css\";\n\nfunction Board({ board, placePiece, colours, toPlayNext }) {\n  let rows = board.length;\n  let tableRows = [];\n  // the first row goes on the bottom, visually\n  for (let row = rows - 1; row > -1; row--) {\n    tableRows.push(\n      <Row\n        key={row}\n        row={board[row]}\n        placePiece={placePiece}\n        colours={colours}\n        toPlayNext={toPlayNext}\n      />\n    );\n  }\n\n  return (\n    <table className=\"board\">\n      <tbody>{tableRows}</tbody>\n    </table>\n  );\n}\n\nfunction Row({ row, placePiece, colours, toPlayNext }) {\n  let rowCells = row.map(({ player, inLine }, col) => {\n    return (\n      <Cell\n        key={col}\n        col={col}\n        player={player}\n        placePiece={placePiece}\n        colours={colours}\n        inLine={inLine}\n        toPlayNext={toPlayNext}\n      />\n    );\n  });\n\n  return <tr>{rowCells}</tr>;\n}\n\n// TODO: cell should only be clickable if current player is next player\n//  and if game is ongoing\nfunction Cell({ col, player, placePiece, colours, inLine, toPlayNext }) {\n  function styleColour() {\n    let backgroundColor = colours[player];\n    let borderColor = inLine\n      ? oppositeColour(backgroundColor)\n      : backgroundColor;\n    return { backgroundColor, borderColor };\n  }\n  const cellClass = player === null ? \"clickable cell\" : \"cell\";\n  const cellOnClick = player === null ? placePiece : (a, b) => {};\n\n  return (\n    <td className={cellClass} onClick={() => cellOnClick(toPlayNext, col)}>\n      {player !== null && <span className=\"piece\" style={styleColour()}></span>}\n    </td>\n  );\n}\n\nfunction oppositeColour(colour) {\n  // TODO: calculate opposite colour (just using Black for now)\n  return \"Black\";\n}\n\nexport default Board;\nexport { Row, Cell }; // for testing\n","function Footer({ resetGame }) {\n  // TODO: Footer component\n  return (\n    <>\n      <p>Footer: game status (onging/lost/etc), game reset options.</p>\n      <button onClick={() => resetGame(0)}>Reset Game</button>\n    </>\n  );\n}\n\nexport default Footer;\n","import { useState, useReducer, useEffect } from \"react\";\n\n//// reducers\n// outside the hook function to ensure they are pure\n\nfunction boardReducer(state, action) {\n  switch (action.type) {\n    case \"reset\":\n      return emptyBoard(action.boardSize);\n    case \"placePiece\":\n      let newState = [...state];\n      // add the piece\n      newState[action.row][action.col].player = action.player;\n      // if there is a new, highlight the winning pieces\n      let { success, r_0, c_0, d_r, d_c } = findWin(\n        newState,\n        action.row,\n        action.col\n      );\n      if (success) {\n        // NOTE: another use of 4 from \"connect 4\"\n        for (let k = 0; k < 4; k++) {\n          newState[r_0 + k * d_r][c_0 + k * d_c].inLine = true;\n        }\n      }\n      return newState;\n    case \"undo\":\n      // NOTE: this case is currently not used\n      // TODO: build in UNDO to interface and add workflow -- note it needs moveHistory passed in\n      if (action.moveHistory === []) {\n        return state;\n      } else {\n        let newState = [...state];\n        delete newState[action.row][action.col].player;\n        // TODO: unhighlight winning positions if necessary\n        return newState;\n      }\n    default:\n      return state;\n  }\n}\n\nfunction historyReducer(state, action) {\n  switch (action.type) {\n    case \"reset\":\n      return [];\n    case \"addMove\":\n      let newState = [...state];\n      let { player, row, col } = action;\n      newState.push({ player, row, col });\n      return newState;\n    case \"undo\":\n      if (state === []) {\n        return state;\n      } else {\n        let newState = [...state];\n        newState.pop();\n        return newState;\n      }\n    default:\n      console.log(\"historyReducer switch didn't match any case\");\n      return state;\n  }\n}\n\n//// helpers for reducers\n\n// create initial empty board (on resets)\nfunction emptyBoard([rows, cols]) {\n  let board = [];\n  for (let r = 0; r < rows; r++) {\n    let row = [];\n    for (let c = 0; c < cols; c++) {\n      row.push({ player: null, inLine: false });\n    }\n    board.push(row);\n  }\n  return board;\n}\n\n// find row that piece will end up in\nfunction findEmptyRow(boardState, col) {\n  let rows = boardState.length;\n  for (let row = 0; row < rows; row++) {\n    if (boardState[row][col].player === null) {\n      return row;\n    }\n  }\n  return null;\n}\n\n//// helpers for effects\n// outside to ensure pure (to avoid being needed in the dependency array)\n\nconst directions = [\n  [0, 1],\n  [1, 0],\n  [1, 1],\n  [-1, 1],\n];\n\nfunction full(board) {\n  let hasNull = false;\n  // check the top row for nulls\n  board[board.length - 1].forEach((entry) => {\n    if (entry.player === null) {\n      hasNull = true;\n    }\n  });\n  return !hasNull;\n}\n\n// NOTE: this is the main place that 4 from \"connect 4\" is used\nfunction findWin(board, row, col) {\n  const [rows, cols] = [board.length, board[0].length];\n  const player = board[row][col].player;\n  if (player === null) {\n    return { success: false };\n  }\n  let success = false;\n  let [r_0, c_0, d_r, d_c] = [null, null, null, null];\n  directions.forEach(([d_row, d_col]) => {\n    if (!success) {\n      // no need to proceed if we already found a win\n      // reset return values\n      [r_0, c_0, d_r, d_c] = [null, null, d_row, d_col];\n      let current = 0;\n      for (let k = -3; k < 4; k++) {\n        if (\n          -1 < row + k * d_row &&\n          row + k * d_row < rows &&\n          -1 < col + k * d_col &&\n          col + k * d_col < cols &&\n          board[row + k * d_row][col + k * d_col].player === player\n        ) {\n          // if the player has a piece here\n          if (current === 0) {\n            // if the piror piece was not compatible (wrong player or out of bounds)\n            // then this is the new start\n            r_0 = row + k * d_row;\n            c_0 = col + k * d_col;\n          }\n          current += 1;\n          if (current >= 4) {\n            // found a winner\n            success = true;\n          }\n        } else {\n          // no piece here -- reset\n          current = 0;\n        }\n      }\n    }\n  });\n\n  return { success, r_0, c_0, d_r, d_c };\n}\n\nfunction useGame(toPlayFirst) {\n  //// Constants\n\n  // to change board dimensions, change this\n  // NOTE: maybe add as prop for hook?\n  const boardSize = [6, 7];\n  // the possible line directions (horizontal, vertical, diagonal, anti-diagonal)\n\n  //// States\n\n  // NOTE: probably better to store board state and winning indices separately,\n  //  then combine them into a const to return to the component,\n  //  rather than having them in the same state -- makes updates more awkward\n\n  // ongoing, draw, or the index of a player\n  const [gameStatus, setGameStatus] = useState(\"ongoing\");\n  // index of player to play next move\n  const [toPlayNext, setToPlayNext] = useState(toPlayFirst);\n  // matrix, row 0 at the bottom; each cell is an object\n  const [board, dispatchMove] = useReducer(boardReducer, emptyBoard(boardSize));\n  // stack (array) of {player, row, col}\n  const [moveHistory, dispatchHistory] = useReducer(historyReducer, []);\n\n  //// Effects\n\n  // check for win/draw\n  useEffect(() => {\n    if (moveHistory.length > 0) {\n      let { row, col } = moveHistory[moveHistory.length - 1];\n      let { success } = findWin(board, row, col);\n      if (gameStatus === \"ongoing\" && success) {\n        // the game state should be the index of the winner\n        setGameStatus(board[row][col].player);\n        setToPlayNext(null);\n      } else if (gameStatus === \"ongoing\" && full(board)) {\n        // it's a draw\n        setGameStatus(\"draw\");\n        setToPlayNext(null);\n      }\n    }\n  }, [moveHistory, board, gameStatus]);\n\n  //// Externally accessible functions\n\n  // given out to reset all states\n  function resetGame(player) {\n    setGameStatus(\"ongoing\");\n    setToPlayNext(player);\n    dispatchMove({ type: \"reset\", boardSize });\n    dispatchHistory({ type: \"reset\" });\n  }\n\n  // given out to allow component to (attempt to) place a piece\n  function placePiece(player, col) {\n    let row = findEmptyRow(board, col);\n    if (gameStatus === \"ongoing\" && player === toPlayNext && row !== null) {\n      // move is possible; proceed\n      dispatchMove({ type: \"placePiece\", player, row, col });\n      dispatchHistory({ type: \"addMove\", player, row, col });\n      setToPlayNext(1 - player);\n      // gameStatus is then updated via a useEffect\n    }\n  }\n\n  // Return\n\n  return { gameStatus, toPlayNext, board, moveHistory, resetGame, placePiece };\n\n  // TODO: return an undo function, rather than the moveHistory?\n}\n\nexport { useGame };\n","import { useState, useReducer } from \"react\";\n\nimport Header from \"./Header.js\";\nimport Board from \"./Board.js\";\nimport Footer from \"./Footer.js\";\n\nimport { useGame } from \"./useGame.js\";\n\nfunction Room({ creator }) {\n  // TODO: Room component\n\n  // TODO: keep playerCount and players up-to-date (useEffect?)\n  // TODO: allow someone to pick who goes first\n\n  // how many players are present\n  // TEMP: initial state\n  const [playerCount, setPlayerCount] = useState(1);\n  // index to access self in players array\n  const selfIndex = creator ? 0 : 1;\n  // other player's name and colour, once they join\n  // TEMP: initial state\n  const [players, setPlayers] = useReducer(playersDispatch, [\n    { name: \"Alice\", colour: \"blue\" },\n    { name: \"Bob\", colour: \"red\" },\n  ]);\n  // the game custom hook\n  // TEMP: argument of 0 (index of first palyer)\n  const {\n    gameStatus,\n    toPlayNext,\n    board,\n    // moveHistory, // TEMP: hide\n    resetGame,\n    placePiece,\n  } = useGame(0);\n\n  function playersDispatch(state, action) {\n    let newState = [...state];\n    newState[action.player][action.property] = action.value;\n    return newState;\n  }\n\n  return (\n    <>\n      <h2>Room</h2>\n      <Header />\n      <Board\n        board={board}\n        placePiece={placePiece}\n        colours={[players[0].colour, players[1].colour]}\n        toPlayNext={toPlayNext}\n      />\n      <Footer gameStatus={gameStatus} resetGame={resetGame} />\n    </>\n  );\n}\n\nexport default Room;\n","import Options from \"./Options.js\";\nimport Lobby from \"./Lobby.js\";\nimport Room from \"./Room.js\";\n\nfunction App() {\n  // TODO: add Links component\n  return (\n    <>\n      <h1>Connect 4 [WIP]</h1>\n      <Options />\n      {true && <Lobby />}\n      {true && <Room />}\n    </>\n  );\n}\n\nexport default App;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\n\nimport App from \"./App\";\n\nimport \"./index.css\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n"],"sourceRoot":""}